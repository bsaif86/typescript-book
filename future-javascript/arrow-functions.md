# Arrow Functions

* [Arrow Functions](arrow-functions.md#arrow-functions)
* [Tip: Arrow Function Need](arrow-functions.md#tip-arrow-function-need)
* [Tip: Arrow Function Danger](arrow-functions.md#tip-arrow-function-danger)
* [Tip: Libraries that use `this`](arrow-functions.md#tip-arrow-functions-with-libraries-that-use-this)
* [Tip: Arrow Function inheritance](arrow-functions.md#tip-arrow-functions-and-inheritance)
* [Tip: Quick object return](arrow-functions.md#tip-quick-object-return)

## Fonctions FlÃ©chÃ©es

On l'appelle affectueusement la _grosse flÃ¨che_ \(parce que `->` est une flÃ¨che fine et `=>` est une grosse flÃ¨che\) et aussi appelÃ©e _fonction lambda_ \(Ã  cause d'autres langages\). Une autre caractÃ©ristique couramment utilisÃ©e est la grosse fonction flÃ©chÃ©e `()=> something`. La motivation pour une _grosse flÃ¨che_ est : 1. Vous n'avez pas besoin de continuer Ã  taper `function` 2. Il capture lexicalement le sens de `this` 2. Il capture lexicalement le sens de `arguments`

Pour un langage qui prÃ©tend Ãªtre fonctionnel, en JavaScript, vous avez tendance Ã  taper beaucoup `function`. La grosse flÃ¨che facilite la crÃ©ation d'une fonction

```typescript
var inc = (x)=>x+1;
```

`this` a toujours Ã©tÃ© un point sensible dans JavaScript. Comme l'a dit un sage "je dÃ©teste JavaScript car il a tendance Ã  perdre trop facilement le sens de `this`". Les grosses flÃ¨ches corrigent cela en capturant la signification de `this` dans le contexte environnant. ConsidÃ©rez cette classe JavaScript pure :

```typescript
function Person(age) {
    this.age = age;
    this.growOld = function() {
        this.age++;
    }
}
var person = new Person(1);
setTimeout(person.growOld,1000);

setTimeout(function() { console.log(person.age); },2000); // 1, aurait du Ãªtre 2
```

Si vous exÃ©cutez ce code dans le navigateur, `this` dans la fonction va pointer vers `window` parce que `window` va Ãªtre ce qui exÃ©cute la fonction `growOld`. Le correctif consiste Ã  utiliser une fonction flÃ©chÃ©e :

```typescript
function Person(age) {
    this.age = age;
    this.growOld = () => {
        this.age++;
    }
}
var person = new Person(1);
setTimeout(person.growOld,1000);

setTimeout(function() { console.log(person.age); },2000); // 2
```

La raison pour laquelle cela fonctionne est que la rÃ©fÃ©rence Ã  `this` est capturÃ©e par la fonction flÃ©chÃ©e depuis l'extÃ©rieur du corps de la fonction. Cela Ã©quivaut au code JavaScript suivant \(ce que vous Ã©cririez vous-mÃªme si vous n'aviez pas TypeScript\) :

```typescript
function Person(age) {
    this.age = age;
    var _this = this;  // capture this
    this.growOld = function() {
        _this.age++;   // utilise le this capturÃ©
    }
}
var person = new Person(1);
setTimeout(person.growOld,1000);

setTimeout(function() { console.log(person.age); },2000); // 2
```

Notez que puisque vous utilisez TypeScript, vous pouvez Ãªtre encore plus doux dans la syntaxe et combiner des flÃ¨ches avec des classes :

```typescript
class Person {
    constructor(public age:number) {}
    growOld = () => {
        this.age++;
    }
}
var person = new Person(1);
setTimeout(person.growOld,1000);

setTimeout(function() { console.log(person.age); },2000); // 2
```

> [Une vidÃ©o sympa sur ce pattern ğŸŒ¹](https://egghead.io/lessons/typescript-make-usages-of-this-safe-in-class-methods)

### Astuce: Besoin de fonction flÃ©chÃ©e

Au-delÃ  de la syntaxe concise, vous n'avez _besoin_ d'utiliser la grosse flÃ¨che que si vous allez donner la fonction Ã  quelqu'un d'autre Ã  appeler. Effectivement :

```typescript
var growOld = person.growOld;
// Plus tard, quelqu'un d'autre l'appelle :
growOld();
```

Si vous allez l'appeler vous-mÃªme, c'est-Ã -dire

```typescript
person.growOld();
```

alors `this` va Ãªtre le contexte d'appel correct \(dans cet exemple `person`\).

### Astuce : Danger de la fonction flÃ©chÃ©e

En fait, si vous voulez que `this` _soit le contexte d'appel_ vous ne devez _pas utiliser la fonction flÃ©chÃ©e_. C'est le cas des callbacks utilisÃ©s par des bibliothÃ¨ques comme jquery, underscore, mocha et autres. Si la documentation mentionne des fonctions sur `this`, vous devriez probablement simplement utiliser une `function` au lieu d'une grosse flÃ¨che. De mÃªme, si vous prÃ©voyez d'utiliser `arguments`, n'utilisez pas de fonction flÃ©chÃ©e.

### Astuce: les fonctions flÃ©chÃ©es avec les bibliothÃ¨ques qui utilisent `this`

De nombreuses bibliothÃ¨ques le font par exemple `jQuery` iterables \(un exemple [https://api.jquery.com/jquery.each/](https://api.jquery.com/jquery.each/)\) utilisera `this` pour vous passer l'objet sur lequel il est en train d'itÃ©rer. Dans ce cas, si vous souhaitez accÃ©der au `this` passÃ© de la bibliothÃ¨que ainsi qu'au contexte environnant, utilisez simplement une variable temporaire comme `_self` comme vous le feriez en l'absence de fonctions flÃ©chÃ©es.

```typescript
let _self = this;
something.each(function() {
    console.log(_self); // la valeur de portÃ©e lexicale
    console.log(this); // la valeur passÃ©e de la librairie
});
```

### Astuce : fonctions flÃ©chÃ©es et hÃ©ritage

Les fonctions flÃ©chÃ©es comme propriÃ©tÃ©s sur les classes fonctionnent bien avec l'hÃ©ritage :

```typescript
class Adder {
    constructor(public a: number) {}
    add = (b: number): number => {
        return this.a + b;
    }
}
class Child extends Adder {
    callAdd(b: number) {
        return this.add(b);
    }
}
// Demo to show it works
const child = new Child(123);
console.log(child.callAdd(123)); // 246
```

Cependant, ils ne fonctionnent pas avec le mot clÃ© `super` lorsque vous essayez de remplacer la fonction dans une classe enfant. Les propriÃ©tÃ©s continuent sur `this`. Puisqu'il n'y a qu'un seul `this` ces fonctions ne peuvent pas participer Ã  un appel Ã  `super` \(`super` ne fonctionne que sur les membres du prototype\). Vous pouvez facilement la contourner en crÃ©ant une copie de la mÃ©thode avant de la remplacer chez l'enfant.

```typescript
class Adder {
    constructor(public a: number) {}
    // Cette fonction est dÃ©sormais sÃ»re Ã  transmettre
    add = (b: number): number => {
        return this.a + b;
    }
}

class ExtendedAdder extends Adder {
    // CrÃ©er une copie du parent avant de crÃ©er le nÃ´tre
    private superAdd = this.add;
    // Now create our override
    add = (b: number): number => {
        return this.superAdd(b);
    }
}
```

## Astuce: retour rapide d'objet

Parfois, vous avez besoin d'une fonction qui renvoie simplement un objet littÃ©ral simple. Cependant, quelque chose comme

```typescript
// MAUVAISE FAÃ‡ON DE LE FAIRE
var foo = () => {
    bar: 123
};
```

est analysÃ© comme un _bloc_ contenant un _Label JavaScript_ par les runtimes JavaScript \(Ã  cause de la spÃ©cification JavaScript\).

> Si cela n'a pas de sens, ne vous inquiÃ©tez pas, car vous obtenez une belle erreur de compilation de TypeScript disant "unused label"\(label inutilisÃ©\) de toute faÃ§on. Les labels sont une ancienne fonctionnalitÃ© JavaScript \(et la plupart du temps inutilisÃ©e\) que vous pouvez ignorer en tant que GOTO moderne \(considÃ©rÃ©e comme mauvaise par les dÃ©veloppeurs expÃ©rimentÃ©s ğŸŒ¹\)

Vous pouvez le corriger en entourant l'objet littÃ©ral avec `()` :

```typescript
// Correct ğŸŒ¹
var foo = () => ({
    bar: 123
});
```

